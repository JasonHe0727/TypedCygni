#ifndef ARRAY_H
#define ARRAY_H
#include "PrimitiveType.h"
#include <vector>
using std::vector;

template <typename T>
class Array
{
public:
    Array();
    Array(int length);
    Array(vector<T> vec);
    Array(const Array& other);
    Array& operator=(const Array& other);
    Array(Array&& other);
    Array& operator=(Array&& other);
    T& operator[](i32 index);
    ~Array();
    i32 Length();
    vector<byte> ToVector();

private:
    i32 length;
    T* items;
};

template <typename T>
Array<T>::Array() : length{0}, items{nullptr}
{
}

template <typename T>
Array<T>::Array(vector<T> vec)
    : length{static_cast<i32>(vec.size())}, items{new T[vec.size()]}
{
    for (u32 i = 0; i < vec.size(); i++)
    {
        items[i] = vec[i];
    }
}

template <typename T>
Array<T>::Array(int length) : length{length}, items{new T[length]}
{
}

template <typename T>
Array<T>::Array(const Array& other)
{
    length = other.length;
    items = new T[length];
    for (i32 i = 0; i < length; i++)
    {
        items[i] = other.items[i];
    }
}

template <typename T>
Array<T>& Array<T>::operator=(const Array& other)
{
    length = other.length;
    items = new T[length];
    for (i32 i = 0; i < length; i++)
    {
        items[i] = other.items[i];
    }
    return *this;
}
template <typename T>
Array<T>::Array(Array&& other)
{
    length = other.length;
    items = other.items;
    other.items = nullptr;
}

template <typename T>
Array<T>& Array<T>::operator=(Array&& other)
{
    length = other.length;
    items = other.items;
    other.items = nullptr;
    return *this;
}

template <typename T>
T& Array<T>::operator[](i32 index)
{
    return items[index];
}

template <typename T>
Array<T>::~Array()
{
    delete[] items;
}

template <typename T>
i32 Array<T>::Length()
{
    return length;
}

template <typename T>
vector<byte> Array<T>::ToVector()
{
    vector<byte> vec(length);
    for (u32 i = 0; i < length; i++)
    {
        vec.at(i) = items[i];
    }
    return vec;
}

#endif // ARRAY_H
